generator client {
  provider = "prisma-client"
  output   = "./generated"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Capture {
  id              String   @id @default(uuid())
  userId          String
  type            String   // SCREENSHOT, TEXT, VIDEO
  content         String   // Text content or URL
  source          String?  // App name (e.g., "Twitter")
  status          String   @default("PENDING") // PENDING, PROCESSED, FAILED
  metadata        String?  // JSON string for extra info
  
  // AI Processing Fields
  aiProcessed     Boolean  @default(false)
  extractedText   String?  // OCR or transcription result
  entities        String?  // JSON: extracted entities (people, places, concepts)
  sentiment       String?  // POSITIVE, NEUTRAL, NEGATIVE
  importanceScore Float?   // 0.0 - 1.0 ranking for essential space
  
  // OCR Processing Fields
  ocrStatus       String   @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  processingError String?  // Error message if OCR/AI processing fails
  
  // Video Processing Fields
  videoStatus     String?  // PENDING, PROCESSING, COMPLETED, FAILED
  transcription   String?  // Full video transcription
  
  tags            Tag[]
  
  screenshotMetadata ScreenshotMetadata?
  extractedContent   ExtractedContent[]
  ranking            ContentRanking?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  deletedAt       DateTime?
  archivedAt      DateTime?

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([aiProcessed])
  @@index([createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, importanceScore])
  @@index([ocrStatus])
}

model ScreenshotMetadata {
  id              String   @id @default(uuid())
  captureId       String   @unique
  ocrText         String?  // Full OCR extracted text
  detectedApp     String?  // App detected from screenshot
  detectedUrl     String?  // URL detected in screenshot
  hasText         Boolean  @default(false)
  hasImage        Boolean  @default(false)
  hasCode         Boolean  @default(false)
  dominantColors  String?  // JSON array of hex colors
  width           Int?
  height          Int?
  fileSize        Int?     // Bytes
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  capture         Capture  @relation(fields: [captureId], references: [id], onDelete: Cascade)

  @@index([captureId])
}

model ExtractedContent {
  id          String   @id @default(uuid())
  captureId   String
  contentType String   // LINK, CODE, QUOTE, CONCEPT, TASK
  content     String
  context     String?  // Surrounding text for context
  position    Int?     // Position in original content
  metadata    String?  // JSON: additional extracted info
  createdAt   DateTime @default(now())
  
  capture     Capture  @relation(fields: [captureId], references: [id], onDelete: Cascade)

  @@index([captureId])
  @@index([contentType])
}

model ContentRanking {
  id                String   @id @default(uuid())
  captureId         String   @unique
  userId            String
  relevanceScore    Float    @default(0.5) // 0.0 - 1.0
  recencyScore      Float    @default(1.0) // Decays over time
  engagementScore   Float    @default(0.0) // Based on user interactions
  finalScore        Float    @default(0.5) // Weighted combination
  isEssential       Boolean  @default(false)
  isPinned          Boolean  @default(false)
  isArchived        Boolean  @default(false)
  lastAccessedAt    DateTime?
  accessCount       Int      @default(0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  capture           Capture  @relation(fields: [captureId], references: [id], onDelete: Cascade)

  @@index([userId, finalScore])
  @@index([userId, isEssential])
}

model Tag {
  id        String   @id @default(uuid())
  name      String
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  captures  Capture[]

  @@unique([userId, name])
  @@index([userId, name])
  @@index([userId])
}

model DocumentUpload {
  id                String   @id @default(uuid())
  userId            String
  fileName          String
  fileType          String   // pdf, docx, txt, etc.
  fileSize          Int
  storageUrl        String
  status            String   @default("UPLOADED") // UPLOADED, PROCESSING, COMPLETED, FAILED
  processingProgress Int     @default(0)
  errorMessage      String?
  metadata          String?  // JSON: pageCount, author, etc.
  
  processedDocument ProcessedDocument?
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([userId])
  @@index([status])
}

model ProcessedDocument {
  id              String   @id @default(uuid())
  uploadId        String   @unique
  
  // Structured Content
  structure       String   // JSON: chapters, sections
  topics          String   // JSON: extracted topics
  
  // Generated Learning Content
  curriculum      String?  // JSON
  flashcards      String?  // JSON
  questions       String?  // JSON
  
  // Analytics
  wordCount       Int      @default(0)
  readingTime     Int      @default(0)
  difficultyScore Float    @default(0.0)
  
  upload          DocumentUpload @relation(fields: [uploadId], references: [id], onDelete: Cascade)
  chunks          DocumentChunk[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model DocumentChunk {
  id              String   @id @default(uuid())
  processedDocId  String
  content         String
  pageNumber      Int?
  embedding       Unsupported("vector(1536)")? // Using pgvector if available
  metadata        String?  // JSON
  
  processedDoc    ProcessedDocument @relation(fields: [processedDocId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime @default(now())
  
  @@index([processedDocId])
}

// --- PART 4: Content Marketplace Models ---

model StudyPack {
  id              String   @id @default(uuid())
  creatorId       String   // Anonymous Creator ID (or User ID if public)
  name            String
  description     String
  topics          String[] // Array of strings
  quality         Float    @default(0.0) // AI Assessed Quality
  price           Int      // In cents (or credits)
  purchaseCount   Int      @default(0)
  encryptedContent String  // JSON (encrypted)
  
  // Optional: Embedding for semantic search (requires vector extension setup)
  // embedding    Unsupported("vector(1536)")? 

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([creatorId])
  @@index([quality(sort: Desc)])
}

model UserPack {
  userId          String
  packId          String
  purchasedAt     DateTime @default(now())
  
  // We can add relation to StudyPack if needed, but keeping it loose for microservice independence
  // For strict integrity, we should relate it:
  // pack        StudyPack @relation(fields: [packId], references: [id])

  @@id([userId, packId])
  @@index([userId])
}

model RevenueTransaction {
  id              String   @id @default(uuid())
  fromUser        String
  toCreator       String
  packId          String
  amount          Int
  platformFee     Int
  status          String   @default("COMPLETED") // COMPLETED, PENDING, REFUNDED
  createdAt       DateTime @default(now())

  @@index([toCreator])
  @@index([createdAt])
}
